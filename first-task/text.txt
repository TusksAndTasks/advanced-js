Задача должна быть реализована на Typescript. Некая сеть фастфудов предлагает несколько видов гамбургеров:

маленький (50 тугриков, 20 калорий)
большой (100 тугриков, 40 калорий)
Гамбургер может быть с одним из нескольких видов начинок (обязательно):

сыром (+ 10 тугриков, + 20 калорий)
салатом (+ 20 тугриков, + 5 калорий)
картофелем (+ 15 тугриков, + 10 калорий)
Дополнительно, гамбургер можно посыпать приправой (+ 15 тугриков, 0 калорий) и полить майонезом (+ 20 тугриков, + 5 калорий). Напиши программу, расчиытвающую стоимость и калорийность гамбургера. Используй ООП подход (подсказка: нужен класс Гамбургер, перечисления, методы для выбора опций и рассчета нужных величин).

Конструктор и публичные методы должны быть затипизированы, необходимо устранить возможность неправильной работы с классом и ее экземплярами при помощи типизации.

Написанный класс должен соответствовать следующему описанию (то есть содержать указанные методы, которые принимают и возвращают данные указанного типа. Комментарии ниже можно скопировать в свой код):

// Размеры, виды начинок и добавок
enum HamburgerSize {}
enum HamburgerStuffing {}
enum HamburgerTopping {}

class Hamburger {
  constructor(private size: HamburgerSize, private stuffing: HamburgerStuffing) {}

  // Добавить добавку к гамбургеру. Можно добавить несколько добавок, при условии, что они разные.
  addTopping(topping: HamburgerTopping): void {}

  // Убрать добавку, при условии, что она ранее была добавлена.
  removeTopping(topping: HamburgerTopping): void {}

  // Получить список добавок.
  getToppings(): HamburgerTopping[] {}

  // Узнать размер гамбургера
  getSize(): HamburgerSize {}

  // Узнать начинку гамбургера
  getStuffing(): HamburgerStuffing {}

  // Узнать цену гамбургера
  calculatePrice(): number {}

  // Узнать калорийность
  calculateCalories(): number {}
}

Комментарии. Эта задача вызывает много непонимания, потому внимательно прочти эти комментарии перед решением.

Эта задача на ООП. Тебе нужно написать класс, который принимает необходимые параметры на входы и возвращает сущность гамбургера на выходе. Никаких взаимодействий с внешним кодом в классе быть не должно, все что используется внутри класса, должно передавать явно, внутрь конструктора, либо метода.

Почему? Потому что каждый должен заниматься своим делом, класс должен только обсчитывать гамбургер, а вводом-выводом пусть занимаются другие. Иначе мы получим кашу, где разные функции смешаны вместе.

Типы начинок, размеры надо сделать перечислениями(константами). Никаких магических строк не должно быть.

Переданную информацию о параметрах гамбургера класс хранит в приватных полях. Вот как может выглядеть использование этого класса:

// маленький гамбургер с начинкой из сыра
var hamburger = new Hamburger(Hamburger.SIZE_SMALL, Hamburger.STUFFING_CHEESE);
// добавка из майонеза
hamburger.addTopping(Hamburger.TOPPING_MAYO);
// спросим сколько там калорий
console.log("Calories: %f", hamburger.calculateCalories());
// сколько стоит
console.log("Price: %f", hamburger.calculatePrice());
// я тут передумал и решил добавить еще приправу
hamburger.addTopping(Hamburger.TOPPING_SPICE);
// А сколько теперь стоит?
console.log("Price with sauce: %f", hamburger.calculatePrice());
// Проверить, большой ли гамбургер?
console.log("Is hamburger large: %s", hamburger.getSize() === Hamburger.SIZE_LARGE); // -> false
// Убрать добавку
hamburger.removeTopping(Hamburger.TOPPING_SPICE);
console.log("Have %d toppings", hamburger.getToppings().length); // 1

При неправильном использовании класса ide должно указывать на допущенную ошибку:

// не передали обязательные параметры
var h2 = new Hamburger();

// передаем некорректные значения, добавку вместо размера
var h3 = new Hamburger(Hamburger.TOPPING_SPICE, Hamburger.TOPPING_SPICE);


Обрати внимание в коде выше на такие моменты:

класс не взаимодействует с внешним миром. Это не его дело, этим занимается другой код, а класс живет в изоляции от мира
обязательные параметры (размер и начинка) мы передаем через конструктор, чтобы нельзя было создать объект, не указав их
необязательные (добавка) добавляем через методы
имена методов начинаются с глагола и имеют вид «сделайЧтоТо»: calculateCalories(), addTopping()
типы начинок обозначены "константами" с понятными именами (на самом деле просто свойствами, написанным заглавными буквами, которые мы договорились считать "константами")
объект создается через конструктор - функцию, которая задает начальные значения полей. Имя класса пишется с большой буквы и обычно является существительным: new Hamburger(...)
в свойствах объекта гамбургера логично хранить исходные данные (размер, тип начинки), а не вычисленные из них (цена, число калорий и т.д.). Рассчитывать цену и калории логично в тот момент, когда это потребуется, а не заранее.
В дополнение, вот еще инструкция, как решать задачи на ООП. Когда ты решаешь задачу на ООП, ты должен ответить на вопросы:

какие есть сущности, для которых мы сделаем классы? (Гамбургер).
какие у них есть свойства (размер, начинка, добавки). Цена или калории не являются свойствами так как они вычисляются из других свойств и хранить их не надо.
что мы хотим от них получить (какие у них должны быть методы). Например, сколько стоит гамбургер?
как сущности связаны? У нас одна сущность «Гамбургер» и она ни с чем не связана.